{% raw %}name: Publish to Package Registry

on:
  workflow_dispatch:
    inputs:
      publish_to_primary:
        description: 'Publish to Primary Registry'
        type: boolean
        required: false
        default: false
env:
  PYTHONUNBUFFERED: True
  PRE_COMMIT_HOME: ${{ github.workspace }}/.precommit_cache

permissions:
  id-token: write # needed to assume OIDC roles (e.g. for downloading from CodeArtifact)
  contents: read # need to explicitly provide this whenever defining permissions because the default value is 'none' for anything not explicitly set when permissions are defined

jobs:
  get-values:
    name: Get Values
    runs-on: {% endraw %}{{ gha_linux_runner }}{% raw %}
    outputs:
      package-version: ${{ steps.extract-package-version.outputs.package_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@{% endraw %}{{ gha_checkout }}{% raw %}
      - name: Setup python
        uses: actions/setup-python@{% endraw %}{{ gha_setup_python }}{% raw %}
        with:
          python-version: {% endraw %}{{ python_version }}{% raw %}
      - name: Extract package version
        id: extract-package-version
        run: |
          VERSION=$(python3 ./.github/workflows/git_tag.py)
          echo "Extracted version: $VERSION"
          echo "package_version=$VERSION" >> $GITHUB_OUTPUT

  lint:
    name: Pre-commit
    uses: ./.github/workflows/pre-commit.yaml
    permissions:
      contents: write # needed for mutex
      id-token: write # needed to assume OIDC roles (e.g. for downloading from CodeArtifact)
    with:
      python-version: {% endraw %}{{ python_version }}{% raw %}

  test:
    needs: [ lint ]
    strategy:
      matrix:
        os:
          - "{% endraw %}{{ gha_linux_runner }}{% raw %}"
{% endraw %}{% if use_windows_in_ci %}          - {{ gha_windows_runner }}{% endif %}{% raw %}
        python-version:
{% endraw %}{% for item in python_ci_versions %}
          - {{ item }}
{% endfor %}{% raw %}
        include:
          - os: "{% endraw %}{{ gha_linux_runner }}{% raw %}"
            python-version: "{% endraw %}{{ python_ci_versions[0] }}{% raw %}"
            JOB_MATCHING_DEV_ENV: true

    runs-on: ${{ matrix.os }}
    env:
      UV_PYTHON: ${{ matrix.python-version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@{% endraw %}{{ gha_checkout }}{% raw %}

      - name: Install python tooling
        uses: ./.github/actions/install_deps
        with:
          python-version: ${{ matrix.python-version }}{% endraw %}{% if python_package_registry == "AWS CodeArtifact" %}{% raw %}
          code-artifact-auth-role-name: CoreInfraBaseAccess
          code-artifact-auth-role-account-id: {% endraw %}{{ aws_central_infrastructure_account_id }}{% raw %}
          code-artifact-auth-region: {% endraw %}{{ aws_org_home_region }}{% endif %}{% raw %}

      - name: Unit test
        run: uv run pytest --durations=5

  build:
    needs: [ test ]
    runs-on: {% endraw %}{{ gha_linux_runner }}{% raw %}

    steps:
      - name: Checkout code
        uses: actions/checkout@{% endraw %}{{ gha_checkout }}{% raw %}

      - name: Install python tooling
        uses: ./.github/actions/install_deps
        with:
          python-version: {% endraw %}{{ python_version }}{% if python_package_registry == "AWS CodeArtifact" %}{% raw %}
          code-artifact-auth-role-name: CoreInfraBaseAccess
          code-artifact-auth-role-account-id: {% endraw %}{{ aws_central_infrastructure_account_id }}{% raw %}
          code-artifact-auth-region: {% endraw %}{{ aws_org_home_region }}{% endif %}{% raw %}

{% endraw %}{% if python_package_registry == "AWS CodeArtifact" %}{% raw %}
      - name: OIDC Auth for Installing any dependencies that uv may need for build (sometimes it likes to install setuptools...even if it's already in the package dependencies)
        uses: aws-actions/configure-aws-credentials@{% endraw %}{{ gha_configure_aws_credentials }}{% raw %}
        with:
          role-to-assume: arn:aws:iam::{% endraw %}{{ aws_central_infrastructure_account_id }}{% raw %}:role/CoreInfraBaseAccess
          aws-region: {% endraw %}{{ aws_org_home_region }}{% raw %}

{% endraw %}{% endif %}{% raw %}
      - name: Build package
        run: |
{% endraw %}{% if python_package_registry == "AWS CodeArtifact" %}{% raw %}          . .devcontainer/code-artifact-auth.sh{% endraw %}{% endif %}{% raw %}
          uv build --no-sources

      - name: Upload build package
        uses: actions/upload-artifact@{% endraw %}{{ gha_upload_artifact }}{% raw %}
        with:
          name: python-package-distributions
          path: dist/
          if-no-files-found: error


  publish-to-staging:
    name: Publish Python distribution to Staging Package Registry
    needs: [ build ]
    runs-on: {% endraw %}{{ gha_linux_runner }}{% raw %}
    environment:
      name: testpypi
      url: https://test.pypi.org/p/{% endraw %}{{ package_name | replace('_', '-') }}{% raw %}
    permissions:
      attestations: write
      id-token: write
    steps:
      - name: Download all the dists
        uses: actions/download-artifact@{% endraw %}{{ gha_download_artifact }}{% raw %}
        with:
          name: python-package-distributions
          path: dist/
{% endraw %}{% if python_package_registry == "AWS CodeArtifact" %}{% raw %}
      - name: OIDC Auth for Publishing to CodeArtifact
        uses: aws-actions/configure-aws-credentials@{% endraw %}{{ gha_configure_aws_credentials }}{% raw %}
        with:
          role-to-assume: arn:aws:iam::{% endraw %}{{ aws_central_infrastructure_account_id }}{% raw %}:role/GHA-CA-Primary-{% endraw %}{{ repo_name }}{% raw %}
          aws-region: {% endraw %}{{ aws_org_home_region }}{% raw %}

      - name: Publish distribution to Code Artifact
        run: |
          . .devcontainer/code-artifact-auth.sh
          uv publish --verbose --index code-artifact-primary --username aws --password "$TWINE_PASSWORD"

{% endraw %}{% else %}{% raw %}
      - name: Publish distribution to Test PyPI
        uses: pypa/gh-action-pypi-publish@{% endraw %}{{ gha_pypi_publish }}{% raw %}
        with:
          attestations: false
          repository-url: https://test.pypi.org/legacy/
{% endraw %}{% endif %}{% raw %}


  install-from-staging:
    name: Install package from staging registry
    needs: [ publish-to-staging, get-values ]
    strategy:
      matrix:
        os:
          - "{% endraw %}{{ gha_linux_runner }}{% raw %}"
{% endraw %}{% if use_windows_in_ci %}          - {{ gha_windows_runner }}{% endif %}{% raw %}
        python-version:
{% endraw %}{% for item in python_ci_versions %}
          - {{ item }}
{% endfor %}{% raw %}
        include:
          - os: "{% endraw %}{{ gha_linux_runner }}{% raw %}"
            python-version: "{% endraw %}{{ python_ci_versions[0] }}{% raw %}"
            JOB_MATCHING_DEV_ENV: true

    runs-on: ${{ matrix.os }}
    env:
      UV_PYTHON: ${{ matrix.python-version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@{% endraw %}{{ gha_checkout }}{% raw %}
      - name: Setup python
        uses: actions/setup-python@{% endraw %}{{ gha_setup_python }}{% raw %}
        with:
          python-version: ${{ matrix.python-version }}
{% endraw %}{% if python_package_registry == "PyPI" %}{% raw %}
      - name: Sleep to allow PyPI Index to update before proceeding to the next step
        if: ${{ runner.os == 'Windows' }}
        uses: juliangruber/sleep-action@{% endraw %}{{ gha_sleep }}{% raw %}
        with:
          time: 60s
      - name: Wait for Test PyPI to serve the new version
        if: ${{ runner.os != 'Windows' }}
        run: |
          set -euo pipefail
          PKG="{% endraw %}{{ package_name | replace('_', '-') }}{% raw %}"
          VER="${{ needs.get-values.outputs.package-version }}"
          for i in $(seq 1 60); do
            code="$(curl -fsS -o /dev/null -w '%{http_code}' "https://test.pypi.org/pypi/${PKG}/${VER}/json" || true)"
            if [ "$code" = "200" ]; then
              echo "Found ${PKG}==${VER} on Test PyPI."
              exit 0
            fi
            echo "Not yet available; sleeping 5s..."
            sleep 5
          done

          if [ "$code" != "200" ]; then
            echo "Timeout waiting for ${PKG}==${VER} on Test PyPI API."
            exit 1
          fi

          # Then try to install with retries to ensure it's actually available in the index
          for i in $(seq 1 12); do
            if pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://www.pypi.org/simple "${PKG}==${VER}" --no-cache-dir --quiet; then
              echo "Successfully installed ${PKG}==${VER}!"
              exit 0
            fi
            echo "Package not yet installable; sleeping 10s... (attempt $i/12)"
            sleep 10
          done

          echo "Timeout waiting for ${PKG}==${VER} to be installable."
          exit 1{% endraw %}{% endif %}{% raw %}
      - name: Install from staging registry
        if: ${{ runner.os == 'Windows' }}
        run: pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://www.pypi.org/simple {% endraw %}{{ package_name | replace('_', '-') }}{% raw %}==${{ needs.get-values.outputs.package-version }} --no-cache-dir
      - name: Display dependencies
        run: pip list
      - name: Confirm library can be imported successfully
        env:
          PYTHONPATH: ""  # avoid picking up local sources
        run: |
          python - <<'PY'
          import sys, importlib, importlib.util, importlib.metadata as md, pathlib
          print(f"Python version {sys.version}")
          mod_name = "{% endraw %}{{ package_name | replace('-', '_') }}{% raw %}"
          dist_name = mod_name
          m = importlib.import_module(mod_name)
          spec = importlib.util.find_spec(mod_name)
          origin = (getattr(spec, "origin", None) or getattr(m, "__file__", "")) or ""
          p = pathlib.Path(origin)
          print(f"Imported from: {p}")
          assert any(s in str(p) for s in ("site-packages", "dist-packages")), f"Expected site/dist-packages, got {p}"
          expected = "${{ needs.get-values.outputs.package-version }}"
          installed = md.version(dist_name)
          print(f"Installed distribution version: {installed} (expected {expected})")
          assert installed == expected, f"Version mismatch: expected {expected}, got {installed}"
          PY

  create-tag:
    name: Create the git tag
    if: ${{ fromJSON(github.event.inputs.publish_to_primary) }}
    needs: [ install-from-staging ]
    permissions:
      contents: write # needed to push the tag
    runs-on: {% endraw %}{{ gha_linux_runner }}{% raw %}
    steps:
      - name: Checkout code
        uses: actions/checkout@{% endraw %}{{ gha_checkout }}{% raw %}
      - name: Setup python
        uses: actions/setup-python@{% endraw %}{{ gha_setup_python }}{% raw %}
        with:
          python-version: {% endraw %}{{ python_version }}{% raw %}
      - name: Confirm tag not already present
        run: python3 ./.github/workflows/git_tag.py --confirm-tag-not-present
      - name: Create tag
        run: python3 ./.github/workflows/git_tag.py --push-tag-to-remote

  publish-to-primary:
    name: Publish Python distribution to Primary Package Registry
    if: ${{ fromJSON(github.event.inputs.publish_to_primary) }}
    needs: [ create-tag ]
    runs-on: {% endraw %}{{ gha_linux_runner }}{% raw %}
    environment:
      name: pypi
      url: https://pypi.org/p/{% endraw %}{{ package_name | replace('_', '-') }}{% raw %}
    permissions:
      attestations: write
      id-token: write
    steps:
      - name: Download all the dists
        uses: actions/download-artifact@{% endraw %}{{ gha_download_artifact }}{% raw %}
        with:
          name: python-package-distributions
          path: dist/
{% endraw %}{% if python_package_registry == "AWS CodeArtifact" %}{% raw %}
      - name: OIDC Auth for Publishing to CodeArtifact
        uses: aws-actions/configure-aws-credentials@{% endraw %}{{ gha_configure_aws_credentials }}{% raw %}
        with:
          role-to-assume: arn:aws:iam::{% endraw %}{{ aws_central_infrastructure_account_id }}{% raw %}:role/GHA-CA-Primary-{% endraw %}{{ repo_name }}{% raw %}
          aws-region: {% endraw %}{{ aws_org_home_region }}{% raw %}

      - name: Publish distribution to Code Artifact
        run: |
          . .devcontainer/code-artifact-auth.sh
          uv publish --verbose --index code-artifact-primary --username aws --password "$TWINE_PASSWORD"

{% endraw %}{% else %}{% raw %}
      - name: Publish distribution to PyPI
        uses: pypa/gh-action-pypi-publish@{% endraw %}{{ gha_pypi_publish }}{% raw %}
        with:
          attestations: false{% endraw %}{% endif %}{% raw %}

  install-from-primary:
    name: Install package from primary registry
    if: ${{ fromJSON(github.event.inputs.publish_to_primary) }}
    needs: [ publish-to-primary, get-values ]
    strategy:
      matrix:
        os:
          - "{% endraw %}{{ gha_linux_runner }}{% raw %}"
{% endraw %}{% if use_windows_in_ci %}          - {{ gha_windows_runner }}{% endif %}{% raw %}
        python-version:
{% endraw %}{% for item in python_ci_versions %}
          - {{ item }}
{% endfor %}{% raw %}
        include:
          - os: "{% endraw %}{{ gha_linux_runner }}{% raw %}"
            python-version: "{% endraw %}{{ python_ci_versions[0] }}{% raw %}"
            JOB_MATCHING_DEV_ENV: true

    runs-on: ${{ matrix.os }}
    env:
      UV_PYTHON: ${{ matrix.python-version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@{% endraw %}{{ gha_checkout }}{% raw %}
      - name: Setup python
        uses: actions/setup-python@{% endraw %}{{ gha_setup_python }}{% raw %}
        with:
          python-version: ${{ matrix.python-version }}
{% endraw %}{% if python_package_registry == "PyPI" %}{% raw %}
      - name: Sleep to allow PyPI Index to update before proceeding to the next step
        if: ${{ runner.os == 'Windows' }}
        uses: juliangruber/sleep-action@{% endraw %}{{ gha_sleep }}{% raw %}
        with:
          time: 60s
      - name: Wait for PyPI to serve the new version
        if: ${{ runner.os != 'Windows' }}
        run: |
          set -euo pipefail
          PKG="{% endraw %}{{ package_name | replace('_', '-') }}{% raw %}"
          VER="${{ needs.get-values.outputs.package-version }}"
          for i in $(seq 1 60); do
            code="$(curl -fsS -o /dev/null -w '%{http_code}' "https://pypi.org/pypi/${PKG}/${VER}/json" || true)"
            if [ "$code" = "200" ]; then
              echo "Found ${PKG}==${VER} on PyPI."
              exit 0
            fi
            echo "Not yet available; sleeping 5s..."
            sleep 5
          done

          if [ "$code" != "200" ]; then
            echo "Timeout waiting for ${PKG}==${VER} on PyPI API."
            exit 1
          fi

          # Then try to install with retries to ensure it's actually available in the index
          for i in $(seq 1 12); do
            if pip install --index-url https://pypi.org/simple/ "${PKG}==${VER}" --no-cache-dir --quiet; then
              echo "Successfully installed ${PKG}==${VER}!"
              exit 0
            fi
            echo "Package not yet installable; sleeping 10s... (attempt $i/12)"
            sleep 10
          done

          echo "Timeout waiting for ${PKG}==${VER} to be installable."
          exit 1{% endraw %}{% endif %}{% raw %}
      - name: Install from primary registry
        if: ${{ runner.os == 'Windows' }}
        run: pip install {% endraw %}{{ package_name | replace('_', '-') }}{% raw %}==${{ needs.get-values.outputs.package-version }} --no-cache-dir
      - name: Display dependencies
        run: pip list
      - name: Confirm library can be imported successfully
        env:
          PYTHONPATH: ""  # avoid picking up local sources
        run: |
          python - <<'PY'
          import sys, importlib, importlib.util, importlib.metadata as md, pathlib
          print(f"Python version {sys.version}")
          mod_name = "{% endraw %}{{ package_name | replace('-', '_') }}{% raw %}"
          dist_name = mod_name
          m = importlib.import_module(mod_name)
          spec = importlib.util.find_spec(mod_name)
          origin = (getattr(spec, "origin", None) or getattr(m, "__file__", "")) or ""
          p = pathlib.Path(origin)
          print(f"Imported from: {p}")
          assert any(s in str(p) for s in ("site-packages", "dist-packages")), f"Expected site/dist-packages, got {p}"
          expected = "${{ needs.get-values.outputs.package-version }}"
          installed = md.version(dist_name)
          print(f"Installed distribution version: {installed} (expected {expected})")
          assert installed == expected, f"Version mismatch: expected {expected}, got {installed}"
          PY{% endraw %}
